### 2.5.1 顺序表和链表的比较

| 维度              | 顺序表（Sequential List）                                    | 链表（Linked List）                                          |
| :---------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **1. 空间性能**   | ① 存储密度 = 1.0（无额外指针） ② 需预分配整块连续空间，可能浪费或溢出 | ① 存储密度 < 1.0（每个结点至少 1 个指针） ② 结点分散分配，用多少申请多少，无“溢出”概念 |
| **2. 时间性能**   | ① 随机存取 **O(1)** ② 插入/删除平均 **O(n)**（移动元素） ③ 按值查找 **O(n)** | ① 随机存取 **O(n)**（必须顺序遍历） ② 插入/删除 **O(1)**（已知前驱） ③ 按值查找 **O(n)** |
| **3. 语言支持**   | ① C 语言可直接用数组、`realloc` 扩容 ② Java 提供 `ArrayList`，自动 1.5 倍扩容；仍涉及拷贝 | ① C 语言需手写指针操作，易出错 ② Java 提供 `LinkedList` 内置实现，无指针风险 |
| **4. 缓存局部性** | 物理相邻，**Cache 友好**                                     | 指针跳转，**Cache 不友好**                                   |
| **5. 内存碎片**   | 大块连续分配，易产生**外部碎片**                             | 结点分散，**内部碎片**小                                     |
| **6. 适用场景**   | 查多改少、长度可预估、需频繁按下标访问（矩阵、哈希桶）       | 改多查少、长度变化大、需频繁插入/删除（队列、图邻接表）      |

### 2.5.2 线性表链式存储方式的比较

|                                      | 找首元素结点                    | 找表尾结点                  | 找P结点前驱结点                                      |
| :----------------------------------- | ------------------------------- | --------------------------- | ---------------------------------------------------- |
| 带头结点单链表L                      | L->next<br>时间耗费$O$(1)       | 一重循环<br >时间耗费$O$(n) | 顺P结点的next域无法找到P结点的前驱                   |
| 带头节点的<br/>循环单链表（头指针）L | L->next<br>时间耗费$O$(1)       | 一重循环<br>时间耗费$O$(n)  | 顺P结点的next域可以找到P结点的前驱<br>时间耗费$O$(n) |
| 带尾指针的<br>循环单链表R            | R->next->next<br>时间耗费$O$(1) | R<br>时间耗费$O$(1)         | 顺P结点的next域可以找到P结点的前驱<br>时间耗费$O$(n) |
| 带头结点的<br>双向循环链表L          | L->next<br>时间耗费$O$(1)       | L->prior<br>时间耗费$O$(1)  | P->prior<br>时间耗费$O$(1)                           |

