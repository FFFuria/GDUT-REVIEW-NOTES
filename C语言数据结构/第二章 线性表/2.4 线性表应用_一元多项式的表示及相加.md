### 1. 一元多项式的表示

对一元多项式$P_{n}(x)+p_{0}+p_{1}x^{1}+p_{2}x^{2}+...+p_{n}x^{n} $

假设$Q_{m}(x)$是一个一元多项式，则它也可以用一个线性表$Q$来表示，即

​							$Q=(q_{0},q{1},q{2},...,q{m})$

若假设m<n，则两个多项式相加的结果$R_{n}(x)=P_{n}(x)+Q_{n}(x)$，也可以用线性表$R$来表示

​				$R=(p_{0}+q_{0},p_{1}+q_{1},p_{2}+q_{2},...,p_{m}+q_{m},p_{m+1},...p_{n})$

### 2. 一元多项式的储存

1. 顺序储存
2. 链式储存

### 3. 一元多项式的相加运算

- 运算规则
	- 所有指数相同的项对应系数相加
	- 若和不为零则构成“和多项式”中的一项
	- 所有指数不相同的项均按升幂复抄到"和多项式" 中
- 算法思路：尾插法生成和多项式
- 初始化（p指LA首元结点，q指LB首元结点，和多项式表尾tail指LA首元结点）
	- p、q两多项式相加比较
		1. p指数<q指数，p结点尾插入和多项式，p后移
		2. p指数=q指数，
			- 系数相加和非0，修改结点p的系数域，释放q结点
			- 系数相加和为0，从polya中删去p结点，同时释放p、q结点
		3. p指数>q指数，将q结点插入p结点之前，指针q在原来的链表上后移

- 代码实现

	```c
	#include <stdio.h>
	#include <stdlib.h>
	
	/* 多项式结点 */
	typedef struct PolyNode {
	    double coef;          /* 系数 */
	    int    expn;          /* 指数 */
	    struct PolyNode *next;
	} PolyNode, *Poly;
	
	/* 创建新结点 */
	static PolyNode *new_node(double c, int e)
	{
	    PolyNode *p = (PolyNode *)malloc(sizeof(PolyNode));
	    if (!p) { perror("malloc"); exit(EXIT_FAILURE); }
	    p->coef = c;
	    p->expn = e;
	    p->next = NULL;
	    return p;
	}
	
	/* 尾插法建立一条降序链表，输入以 (0, -1) 结束 */
	Poly create_poly(void)
	{
	    Poly head = new_node(0, -1);   /* 头结点 */
	    Poly tail = head;
	    double c;
	    int e;
	    while (scanf("%lf%d", &c, &e) == 2 && e >= 0) {
	        if (c == 0.0) continue;    /* 跳过零系数项 */
	        PolyNode *p = new_node(c, e);
	        tail->next = p;
	        tail = p;
	    }
	    return head;
	}
	
	/* 打印多项式 */
	void print_poly(const Poly head)
	{
	    for (PolyNode *p = head->next; p; p = p->next) {
	        printf("%+.2fx^%d", p->coef, p->expn);
	        if (p->next) putchar(' ');
	    }
	    puts("");
	}
	
	/* 核心：多项式相加，返回一条全新降序链表 */
	Poly poly_add(const Poly pa, const Poly pb)
	{
	    Poly ha = pa->next, hb = pb->next;   /* 工作指针 */
	    Poly head = new_node(0, -1);          /* 结果头结点 */
	    Poly tail = head;
	
	    while (ha && hb) {
	        if (ha->expn > hb->expn) {
	            tail->next = new_node(ha->coef, ha->expn);
	            ha = ha->next;
	        } else if (ha->expn < hb->expn) {
	            tail->next = new_node(hb->coef, hb->expn);
	            hb = hb->next;
	        } else {                          /* 指数相等 */
	            double c = ha->coef + hb->coef;
	            if (c != 0.0)
	                tail->next = new_node(c, ha->expn);
	            ha = ha->next;
	            hb = hb->next;
	        }
	        if (tail->next) tail = tail->next;
	    }
	    /* 复制剩余段 */
	    for (; ha; ha = ha->next) tail->next = new_node(ha->coef, ha->expn),
	                                tail = tail->next;
	    for (; hb; hb = hb->next) tail->next = new_node(hb->coef, hb->expn),
	                                tail = tail->next;
	    return head;
	}
	
	/* 释放链表 */
	void destroy_poly(Poly head)
	{
	    PolyNode *p;
	    while (head) { p = head; head = head->next; free(p); }
	}
	
	/* 简单测试 */
	int main(void)
	{
	    printf("输入第一个多项式（系数 指数），以 (0 -1) 结束：\n");
	    Poly p1 = create_poly();
	    printf("输入第二个多项式（系数 指数），以 (0 -1) 结束：\n");
	    Poly p2 = create_poly();
	
	    Poly sum = poly_add(p1, p2);
	    printf("相加结果：");
	    print_poly(sum);
	
	    destroy_poly(p1);
	    destroy_poly(p2);
	    destroy_poly(sum);
	    return 0;
	}
	```