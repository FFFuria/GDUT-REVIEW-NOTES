# 2.3 线性表的链式存储结构

用任意存储块 + 指针表示逻辑次序，malloc 随时申请，free 随时释放。

## 2.3.1 单链表

### 1 结点定义
typedef struct Node {
    ElemType data;
    struct Node *next;
} Node, *LinkList;

### 2 建表
| 方法   | 链序 vs 输入 | 核心   | 复杂度 |
| ------ | ------------ | ------ | ------ |
| 头插法 | 逆序         | 新当头 | O(n)   |
| 尾插法 | 一致         | 新接尾 | O(n)   |

头插法代码：
LinkList create_head(ElemType *a,int n){
    LinkList head=NULL;
    for(int i=0;i<n;i++){
        Node *p=(Node*)malloc(sizeof(Node));
        p->data=a[i]; p->next=head; head=p;
    }
    return head;
}

尾插法代码：
LinkList create_tail(ElemType *a,int n){
    Node *head=NULL,*tail=NULL;
    for(int i=0;i<n;i++){
        Node *p=(Node*)malloc(sizeof(Node));
        p->data=a[i]; p->next=NULL;
        if(!head) head=tail=p;
        else{ tail->next=p; tail=p; }
    }
    return head;
}

### 3 查找
按序号：走 i-1 步，O(n)  
按值：顺序比较，返回首匹配指针，O(n)

### 4 插入（后插）
s->next=p->next; p->next=s;   // O(1)

### 5 删除
按位序（带头结点）：
bool ListDelete_L(LinkList L,int i,ElemType *e){
    Node *p=L; int j=0;
    while(p&&j<i-1){p=p->next;j++;}
    if(!p||!p->next)return false;
    Node *q=p->next; *e=q->data;
    p->next=q->next; free(q);
    return true;
}
按值删除首结点：
bool DelVal_L(LinkList L,ElemType val){
    Node *pre=L,*p=L->next;
    while(p&&p->data!=val){pre=p;p=p->next;}
    if(!p)return false;
    pre->next=p->next; free(p);
    return true;
}
复杂度：查找 O(n) + 删除 O(1)

### 6 清空/销毁
void DestroyList(LinkList *L){
    Node *p=*L;
    while(p){ Node *q=p; p=p->next; free(q); }
    *L=NULL;
}

### 7 特点
优点：插入/删除 O(1)（已知前驱）、无溢出、动态扩容  
缺点：无随机访问、额外指针域、缓存不友好

### 8 实战技巧
1. 带头结点：统一空/非空判断  
2. 循环链表：尾指针 rear，rear->next 得头，适合队列  
3. 双向链表：加 prior 指针，删除前驱 O(1)  
4. 调试：free 后立即置 NULL，Valgrind 查泄漏

## 2.3.2 循环链表（Circular Linked List）

> 尾结点 next 不回 NULL，而是回头，形成“环”。
> 只需任意一个入口（常用尾指针 rear）即可遍历全表。

---

### 1 结构特点
- 空表：rear == NULL  
- 非空：rear->next == 头结点（带头结点）或 首元结点（不带头）

### 2 与单链表核心差异
| 操作         | 单链表          | 循环链表                 |
| ------------ | --------------- | ------------------------ |
| 判尾         | p->next == NULL | p->next == head          |
| 遍历结束条件 | p == NULL       | p == head（入口）        |
| 找头         | head 指针       | rear ? rear->next : NULL |

---

### 3 基本运算（带头结点，尾指针实现）

#### 3.1 初始化
```c
Node *rear = NULL;          // 空环
```

#### 3.2 尾插法建表（顺序输入）

```c
Node* create_circ_tail(ElemType *a, int n){
    Node *rear = NULL;
    for(int i = 0; i < n; ++i){
        Node *p = (Node*)malloc(sizeof(Node));
        p->data = a[i];
        if(!rear){                 // 第一个结点
            rear = p;
            rear->next = rear;     // 自环
        }else{
            p->next = rear->next;  // p->next = head
            rear->next = p;        // 尾连新结点
            rear = p;              // 更新尾指针
        }
    }
    return rear;                   // 返回尾指针即可
}
```

时间：O(n) 空间：O(1)

#### 3.3 按序号查找（第 i 个，1≤i≤n）

```c
Node* GetCirc(Node *rear, int i){
    if(!rear) return NULL;
    Node *p = rear->next;          // 指向头
    int j = 1;
    do{
        if(j == i) return p;
        j++;  p = p->next;
    }while(p != rear->next);       // 绕回即停
    return NULL;                   // i 非法
}
```

平均 O(n)

#### 3.4 在首元前插入（等价尾插）

```c
void InsertFront(Node **rear, ElemType e){
    Node *p = (Node*)malloc(sizeof(Node));
    p->data = e;
    if(!*rear){                    // 空环
        p->next = p;
        *rear = p;
    }else{
        p->next = (*rear)->next;   // p->head
        (*rear)->next = p;         // 尾->next = p
    }
}
```

O(1)

#### 3.5 删除首元结点

```c
bool DeleteFirst(Node **rear, ElemType *e){
    if(!*rear) return false;
    Node *head = (*rear)->next;
    *e = head->data;
    if(head == *rear)              // 仅一个结点
        *rear = NULL;
    else
        (*rear)->next = head->next;
    free(head);
    return true;
}
```

O(1)

#### 3.6 遍历输出

```c
void PrintCirc(Node *rear){
    if(!rear) return;
    Node *p = rear->next;
    do{
        printf("%d ", p->data);
        p = p->next;
    }while(p != rear->next);
    printf("\n");
}
```

------

### 4 循环链表 vs 单链表实战优势

1. 队列（FIFO）
	rear 指针直接提供 **O(1)** 入队（尾插）与出队（删除首元），无需额外头指针。
2. 约瑟夫问题（报数出圈）
	环形天然适合“数到 m 删一个”的循环计数，避免模运算越界。
3. 多进程时间片轮询
	任务控制块挂成环，调度器循环遍历即可。

------

### 5 双向循环链表（简要）

- 再加 `prior` 指针，形成“前+后”双环
- 插入/删除依旧“交叉指”，但无需判头尾边界
- Linux 内核链表即为典型双向循环链表实现

------

### 6 易错清单

| 错误                             | 现象       | 修正                              |
| :------------------------------- | :--------- | :-------------------------------- |
| 忘把 rear->next 指向头           | 遍历死循环 | 建表/插入后强制 `p->next = head`  |
| 只剩一个结点时删除未置 rear NULL | 野指针     | 删除后 `if(rear==head) rear=NULL` |
| 空表仍执行 `rear->next`          | 段错误     | 任何操作前 `if(!rear) return;`    |

------

### 7 口诀速记

> 循环链表不回头，
> 尾指头来头连尾；
> 插入删除 O(1) 走，
> 约瑟夫队列不用愁。