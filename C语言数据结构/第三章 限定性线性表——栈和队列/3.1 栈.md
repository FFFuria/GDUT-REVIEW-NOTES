### 3.1.1 栈的定义

栈是一种**运算受限的线性表**，其**插入、删除和访问操作都只能在线性表的同一端进行**。这一端称为**栈顶（top）**，另一端称为**栈底（bottom）**。

- **后进先出**（LIFO，Last In First Out）是栈的根本特征。
- 基本操作（最小功能集）
	1. `push(x)`：把元素 x **压入**栈顶。
	2. `pop()`：把栈顶元素**弹出**并返回（或仅删除）。
	3. `top()/peek()`：**读取**栈顶元素但不弹出。
	4. `isEmpty()`：判空。
	5. `size()`：返回当前元素个数。
- 存储实现
	- **顺序栈**：用一段**连续存储空间**（数组）+ 整型 `top` 指针（或下标）。
	- **链式栈**：用**不带头结点的单链表**，所有操作在**链表头**完成；头指针即栈顶指针。

### 3.1.2 栈的表示和实现

#### 1. 顺序栈

**存储结构**：用一维数组 `data[maxSize]` 存储栈元素，`top` 指针表示栈顶位置（初始值为 `-1` 表示空栈，`top == maxSize - 1` 表示栈满），`maxSize` 为栈的最大容量。

```c
#define maxSize 100  // 栈的最大容量
typedef struct {
    int data[maxSize];  // 存储栈元素
    int top;            // 栈顶指针
} SeqStack;
```

1. 初始化

​	初始化栈顶指针为 `-1`，表示栈为空。

```c
void initStack(SeqStack &st) {
    st.top = -1;  // 空栈标志
}
```

2. 进栈

​	先判断栈是否已满，若未满则栈顶指针加 1，再存入元素。

```c
bool push(SeqStack &st, int x) {
    if (st.top == maxSize - 1) return false;  // 栈满，进栈失败
    st.data[++st.top] = x;  // 栈顶指针上移，存入元素
    return true;
}
```

3. 出栈

​	先判断栈是否为空，若不空则返回栈顶元素，栈顶指针减 1。

```c
bool pop(SeqStack &st, int &x) {
    if (st.top == -1) return false;  // 栈空，出栈失败
    x = st.data[st.top--];  // 取出栈顶元素，栈顶指针下移
    return true;
}
```

4. 读栈顶元素

​	栈非空时返回栈顶元素，不修改栈顶指针。

```c
bool getTop(SeqStack st, int &x) {
    if (st.top == -1) return false;  // 栈空，无元素
    x = st.data[st.top];  // 读取栈顶元素
    return true;
}
```

5. 多栈共享元素

#### 2. 链栈

1. 进栈操作
2. 出栈操作
3. 多栈运算

### 3.1.3 栈的应用举例

#### 1. 括号匹配问题

思想：利用设置一个括号栈判别左右括号个数与类型匹配情况

若读入**左括号**则入栈，等待相匹配的同类**左括号**

若读入**右括号**且与栈顶的**左括号**类型匹配，栈顶**左括号**出栈，否则属于不合法

#### 2. 表达式求值（中缀转后缀 + 后缀计算）

- **中缀表达式转后缀表达式（逆波兰式）**规则：

	1. 数字直接输出；
	2. 运算符入栈前，弹出栈中优先级更高或相等的运算符（除括号外）；
	3. 左括号 `(` 直接入栈，右括号 `)` 弹出栈顶元素直到遇到 `(`（`(` 不输出）；
	4. 遍历结束后，弹出栈中剩余运算符。

	示例：中缀 `3 + 4 * 2 / (1 - 5)` → 后缀 `3 4 2 * 1 5 - / +`

- **后缀表达式计算**思想：用栈存储操作数

	1. 遍历后缀表达式，遇到数字入栈；
	2. 遇到运算符，弹出栈顶两个元素（后弹出的为左操作数），计算后将结果入栈；
	3. 遍历结束后，栈中剩余元素即为结果。

#### 3. 函数调用栈

- 程序运行时，函数调用通过栈管理：
	- 调用函数时，将返回地址、局部变量、参数等压入栈；
	- 函数执行结束后，从栈顶弹出上述信息，回到调用位置继续执行。
- 递归函数本质是反复调用自身，依赖栈保存每层递归的状态，递归深度过深可能导致栈溢出。

#### 4. 浏览器历史记录

- 浏览器的「前进」「后退」功能基于栈实现：
	- 访问新页面时，当前页面压入「后退栈」；
	- 点击「后退」，从「后退栈」弹出页面并压入「前进栈」；
	- 点击「前进」，从「前进栈」弹出页面并压入「后退栈」。

### 3.1.4 栈的时间复杂度与空间复杂度

- 时间复杂度：

	push()、pop()、top()、isEmpty() 等操作均仅涉及栈顶元素，时间复杂度为O(1)。

- 空间复杂度：

	- 顺序栈：固定大小 `O(maxSize)`；
	- 链栈：动态分配，最坏情况 `O(n)`（n 为元素个数）。

### 3.1.5 栈的常见问题

- 栈溢出：

	- 顺序栈：元素个数超过 `maxSize` 时发生「上溢」；
	- 链栈：理论无固定上限，但内存不足时会溢出。

- 多栈共享：

	多个栈共享一块连续内存（如数组两端分别作为两个栈的栈底），提高空间利用率。