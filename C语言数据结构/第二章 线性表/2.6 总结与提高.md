### 一、顺链操作技术（“顺链”） 场景：
链表（或顺序表）**原地**遍历，**不需要回头**再找前驱/后继。
做法：

1. 进入循环前，先用一个**前驱指针** `prev` 保存**当前位置**。
2. 正常迭代 `p = p->next;`
3. 由于 `prev` 已经提前“定格”在上一步，**即使 `p` 继续往后走，也能通过 `prev` 拿到前驱**，从而完成“删除/插入”而**无需再从头找**。

代码模板（以删除第一个值为 `x` 的结点为例）：

```c
Node *prev = NULL;
for (Node *p = head; p; ) {
    if (p->data == x) {          // 找到目标
        if (prev == NULL)        // 删头结点
            head = p->next;
        else
            prev->next = p->next;
        free(p);
        break;
    }
    prev = p;        // 1. 先保留“当前”作为下一次的前驱
    p = p->next;     // 2. 再顺链后移
}
```

口诀记忆：
**“先留 prev，再挪 p”** —— 这就是“顺链操作技术”的全部内容。

------

### 二、指针保留技术（“保留”） 场景：
**插入或删除**某结点时，**必须知道它的前驱**，但链表**单向**，一旦 `p` 后移就回不来。
做法：

1. 在进入下一轮循环之前，**额外保存一份“前驱”指针**（通常命名 `prev` / `pre` / `front`）。
2. 真正需要修改指针域时，直接操作 `prev->next`，**无需重新遍历**。

代码模板（把值为 `x` 的前一个结点后面插入 `y`）：

```c
Node *prev = NULL;
for (Node *p = head; p; p = p->next) {
    if (p->data == x) {
        Node *s = malloc(sizeof(Node));
        s->data = y;
        s->next = p;
        if (prev)          // 非头插
            prev->next = s;
        else               // 头插
            head = s;
        break;
    }
    prev = p;   // 保留“当前”作为下一次的前驱
}
```

口诀记忆：
**“先用 prev 定格，再动 p”** —— 这就是“指针保留技术”。